# Основы написания сценариев

> – "А что у вас есть?"<br>
> – "Что у нас есть?" – спросил горбоносый поворачиваясь.<br>
> – "Алдан-3", – сказал бородатый.<br>
> – "Богатая машина, – сказал я. – И хорошо работает?"<br>
> – "Да как вам сказать..."<br>
> – "Понятно", – сказал я.<br>
> – "Собственно, ее еще не отладили, – сказал бородатый. – Оставайтесь у нас, отладите..."
> 
> __А. и Б. Стругацкие, *Понедельник начинается в субботу*__

- [Основы написания сценариев](#основы-написания-сценариев)
  - [Настройка окружения](#настройка-окружения)
    - [Переменные среды](#переменные-среды)
    - [Инструменты командной строки](#инструменты-командной-строки)
  - [Написание Shell скриптов в Bash](#написание-shell-скриптов-в-bash)
    - [Переменные и типы данных](#переменные-и-типы-данных)
      - [Целые числа](#целые-числа)
      - [Действительные числа](#действительные-числа)
      - [Строки](#строки)
      - [Массивы](#массивы)
    - [Условные операторы и циклы](#условные-операторы-и-циклы)
      - [Операторы сравнения](#операторы-сравнения)
      - [Оператор if](#оператор-if)
      - [Цикл for](#цикл-for)
      - [Цикл while](#цикл-while)
      - [Цикл until](#цикл-until)
    - [Функции](#функции)
      - [Локальные переменные](#локальные-переменные)
      - [Параметры Shell скрипта](#параметры-shell-скрипта)
    - [Обработка ошибок](#обработка-ошибок)
    - [Вызов внешних команд и скриптов](#вызов-внешних-команд-и-скриптов)
    - [Примеры простых скриптов](#примеры-простых-скриптов)
      - [Пример 1. Резервное копирование файла](#пример-1-резервное-копирование-файла)
      - [Пример 2. Подсчет количества строк в файле](#пример-2-подсчет-количества-строк-в-файле)
      - [Пример 3. Подсчет количества строк в файле, функциональный стиль](#пример-3-подсчет-количества-строк-в-файле-функциональный-стиль)
      - [Пример 4. Слияние нескольких текстовых файлов в один](#пример-4-слияние-нескольких-текстовых-файлов-в-один)
  - [Библиография](#библиография)

## Настройка окружения

### Переменные среды

Любая операционная система имеет свою собственную конфигурацию, которая определяет, как она работает и взаимодействует с пользователем и приложениями. Одним из ключевых аспектов этой конфигурации являются переменные среды (environment variables).

*Переменные среды* — это динамические значения, которые могут влиять на поведение процессов в операционной системе. Они используются для хранения информации, такой как пути к исполняемым файлам, настройки языка, параметры конфигурации приложений и многое другое.

Основными переменными среды в Unix-подобных системах (таких как Linux и macOS) являются:

- `PATH`: определяет список директорий, в которых система ищет исполняемые файлы. Когда вы вводите команду в терминале, система просматривает эти директории в указанном порядке, чтобы найти соответствующий исполняемый файл.
- `HOME`: указывает на домашнюю директорию текущего пользователя. Это место, где хранятся личные файлы и настройки пользователя.
- `USER`: содержит имя текущего пользователя.
- `SHELL`: указывает на используемую оболочку командной строки (например, `/bin/bash` или `/bin/zsh`).
- `LANG`: определяет язык и региональные настройки для приложений.
- `EDITOR`: указывает на предпочитаемый текстовый редактор для командной строки (например, `vim`, `nano` или `emacs`).
- `TMPDIR`: указывает на директорию для временных файлов.
- `PWD`: содержит текущую рабочую директорию.
- `OLDPWD`: содержит предыдущую рабочую директорию.

Переменные среды могут быть установлены и изменены пользователем или приложениями. В Unix-подобных системах это обычно делается с помощью команд `export` в оболочке. Например, чтобы добавить новую директорию в переменную `PATH`, можно использовать следующую команду:

```bash
export PATH=$PATH:/new/directory/path
```

Переменная среды будет действовать только в текущей сессии оболочки. Чтобы сделать изменения постоянными, их можно добавить в файл конфигурации оболочки, такой как `~/.bashrc`, `~/.bash_profile` или `~/.zshrc`, в зависимости от используемой оболочки.

### Инструменты командной строки

*Командная строка* (англ. CLI, Command Line Interface) — это текстовый интерфейс, который позволяет пользователям взаимодействовать с операционной системой или программами с помощью текстовых команд. В отличие от графического интерфейса (GUI), где взаимодействие происходит через окна, кнопки и меню, в командной строке пользователь вводит команды вручную.

Командная строка предоставляет мощные инструменты для управления системой, выполнения задач и автоматизации процессов. Вот некоторые из основных инструментов командной строки, которые часто используются в Unix-подобных системах:

- `ls`: отображает список файлов и директорий в текущей директории.
- `cd`: изменяет текущую рабочую директорию.
- `pwd`: выводит полный путь текущей рабочей директории.
- `cp`: копирует файлы и директории.
- `mv`: перемещает или переименовывает файлы и директории.
- `rm`: удаляет файлы и директории.
- `mkdir`: создает новые директории.
- `rmdir`: удаляет пустые директории.
- `touch`: создает пустой файл или обновляет временную метку существующего файла.
- `cat`: выводит содержимое файла на экран.
- `echo`: выводит текст или значения переменных на экран.
- `bc`: консольный калькулятор для выполнения арифметических операций.
- `find`: ищет файлы и директории по заданным критериям.
- `awk`: мощный текстовый процессор для обработки и анализа текстовых данных.
- `grep`: ищет текстовые строки, соответствующие заданному шаблону.

Команды в командной строке могут быть комбинированы с помощью конвейеров (pipes) и перенаправлений (redirections) для создания сложных операций. Например, команда `ls -l | grep "\.txt$"` выведет список всех файлов с расширением `.txt` в текущей директории.

Существуют следующие операторы:

- `|` (pipe): перенаправляет вывод одной команды на вход другой команды.
- `>`: перенаправляет вывод команды в файл, перезаписывая его содержимое.
- `>>`: перенаправляет вывод команды в файл, добавляя его к существующему содержимому.
- `<`: перенаправляет ввод команды из файла.
- `2>`: перенаправляет стандартный поток ошибок в файл.
- `&>`: перенаправляет и стандартный вывод, и стандартный поток ошибок в файл.
- `&&`: выполняет вторую команду только если первая команда завершилась успешно (код возврата 0).
- `||`: выполняет вторую команду только если первая команда завершилась с ошибкой (код возврата не 0).
- `;`: позволяет выполнять несколько команд последовательно, независимо от результата предыдущей команды.
- `$()`: выполняет команду внутри скобок и возвращает её вывод, который можно использовать в другой команде.

Пример использования операторов:

```bash
# Пример находит все текстовые файлы в текущей директории и сохраняет их в файл, одновременно записывая ошибки в отдельный лог-файл
ls -l | grep "\.txt$" > txt_files.txt 2> errors.log
```

## Написание Shell скриптов в Bash

Команды командной строки можно объединять в *скрипты* (или сценарии) для автоматизации задач. Скрипты позволяют выполнять последовательность команд, использовать переменные, условные операторы и циклы, что делает их мощным инструментом для автоматизации рутинных операций.

Скрипты обычно имеют расширение `.sh` и могут быть выполнены в командной строке. Скрипт начинается с "шебанга" (англ. shebang) — строки, указывающей интерпретатор, который будет использоваться для выполнения скрипта. Например, для Bash это будет:

```bash
#!/bin/bash
```

После шебанга идут команды, которые будут выполняться последовательно. Вот пример простого скрипта, который выводит "Hello, World!" и текущую дату:

```bash
#!/bin/bash
echo "Hello, World!"
date
```

Чтобы выполнить скрипт, необходимо сделать его исполняемым с помощью команды `chmod +x script.sh`, а затем запустить его с помощью `./script.sh`.

### Переменные и типы данных

В Bash можно использовать переменные для хранения данных. Переменные создаются простым присваиванием значения:

```bash
#!/bin/bash
name="John"
age=30
```

> [!NOTE]
> При инициализации переменных не должно быть пробелов вокруг знака равенства `=`.

Для доступа к значению переменной используется знак доллара `$`. Кроме того, можно, а часто даже полезно, использовать фигурные скобки для обозначения границ имени переменной:

```bash
echo "Name: $name"
echo "Age: ${age}"
```

> [!NOTE]
> При использовании переменных внутри строк рекомендуется брать их в фигурные скобки `${variable}`, чтобы избежать неоднозначностей.

В Bash нет строгой типизации переменных. Все переменные по умолчанию считаются строками. Однако, в зависимости от контекста, они могут использоваться как числа (для арифметических операций) или как массивы.

#### Целые числа

Для выполнения арифметических операций с целыми числами в Bash используются двойные круглые скобки `(( ))`:

```bash
num1=10
num2=5
sum=$((num1 + num2))
echo "Sum: ${sum}"
```

#### Действительные числа

Bash не поддерживает операции с плавающей точкой, поэтому для работы с действительными числами используется консольный калькулятор `bc` (Basic Calculator):

```bash
num1=10.5
num2=5.3
sum=$(echo "${num1} + ${num2}" | bc)
echo "Sum: ${sum}"
```

#### Строки

Для определения строк используются двойные или одинарные кавычки. В одинарных кавычках переменные используются буквально, а в двойных кавычках — обрабатываются (интерполируются), то есть, при использовании переменных внутри двойных кавычек, их значения подставляются:

```bash
greeting="Hello"
echo '${greeting}, World!'  # Выведет: ${greeting}, World!
echo "${greeting}, World!"   # Выведет: Hello, World!
```

При помощи фигурных скобок можно выполнять следующие операции со строками:

- Получение длины строки;
- Извлечение подстроки;
- Замена подстроки;
- Преобразование регистра.

__Получение длины строки__
Для получения длины строки используется синтаксис `${#variable}`:

```bash
str="Hello"
echo "Length: ${#str}"  # Выведет: Length: 5
```

__Извлечение подстроки__
Для извлечения подстроки используется синтаксис `${variable:start:length}`:

```bash
str="Hello, World!"
echo "Substring: ${str:7:5}"  # Выведет: Substring: World
```

Если не указывать длину, будет извлечена подстрока от указанной позиции до конца строки:

```bash
str="Hello, World!"
echo "Substring: ${str:7}"  # Выведет: Substring: World!
```

__Замена подстроки__
Для замены подстроки используется синтаксис `${variable/pattern/replacement}`:

```bash
str="Hello, World!"
echo "Replaced: ${str/World/Bash}"  # Выведет: Replaced: Hello, Bash!
```

Для замены всех вхождений используется двойной слэш `//` (`${variable//pattern/replacement}`):

```bash
str="Hello, World!"
echo "Replaced all: ${str//o/O}"      # Выведет: Replaced all: HellO, WOrld!
```

__Преобразование регистра__
Для преобразования регистра символов в верхний регистр используется запись `${variable^^}`:

```bash
str="Hello, World!"
echo "Uppercase: ${str^^}"  # Выведет: Uppercase: HELLO, WORLD!
```

Для преобразования регистра символов в нижний регистр используется запись `${variable,,}`:

```bash
str="Hello, World!"
echo "Lowercase: ${str,,}"  # Выведет: Lowercase: hello, world!
```

#### Массивы

Массивы в Bash — это упорядоченные коллекции элементов, каждый из которых идентифицируется по индексу. Массивы незаменимы для обработки списков файлов, аргументов командной строки или результатов выполнения команд. Понимание операций с массивами позволяет писать скрипты, которые эффективно обрабатывают большие объемы данных.

__Создание и инициализация массивов:__
Массивы создаются с помощью круглых скобок. Элементы массива разделяются пробелами:

```bash
fruits=("apple" "banana" "cherry")
numbers=(1 2 3 4 5)
mixed=("text" 42 "another text")
```

__Доступ к элементам массива:__
Элементы массива доступны по индексу (начиная с 0):

```bash
echo "First fruit: ${fruits[0]}"   # Outputs: First fruit: apple
echo "Second fruit: ${fruits[1]}"  # Outputs: Second fruit: banana
echo "Third fruit: ${fruits[2]}"   # Outputs: Third fruit: cherry
```

__Получение всех элементов:__
Получить все элементы массива можно, используя `${array[@]}` или `${array[*]}`:

```bash
echo "All fruits: ${fruits[@]}"  # Outputs: All fruits: apple banana cherry
```

__Определение размера массива:__
Количество элементов в массиве можно узнать с помощью `${#array[@]}`:

```bash
echo "Number of fruits: ${#fruits[@]}"  # Outputs: Number of fruits: 3
```

__Добавление элементов:__
Добавление новых элементов в массив осуществляется, при помощи указания индекса или используя оператор `+=`:

```bash
fruits[3]="orange"
fruits+=("grape" "kiwi")
```

### Условные операторы и циклы

Условные операторы и циклы позволяют управлять потоком выполнения скрипта в зависимости от условий и повторять выполнение команд. Как условные операторы, так и циклы являются фундаментальными конструкциями в программировании, позволяющими создавать более сложные и динамичные сценарии.

Условные операторы и циклы для определения направления логики выполнения используют операторы сравнения.

#### Операторы сравнения

В Bash доступны следующие операторы сравнения для различных типов данных.

__Числовые операторы сравнения:__

- `-eq` : равно (equal)
- `-ne` : не равно (not equal)
- `-lt` : меньше (less than)
- `-le` : меньше или равно (less or equal)
- `-gt` : больше (greater than)
- `-ge` : больше или равно (greater or equal)

Пример:

```bash
num1=10
num2=20
if [ $num1 -lt $num2 ]; then
    echo "${num1} меньше ${num2}"
fi
```

__Строковые операторы сравнения:__

- `=` или `==` : строки равны
- `!=` : строки не равны
- `<` : строка лексикографически меньше
- `>` : строка лексикографически больше
- `-z` : строка пустая (zero length)
- `-n` : строка непустая (non-zero length)

Пример:

```bash
str1="hello"
str2="world"
if [ "${str1}" != "${str2}" ]; then
    echo "Строки не равны"
fi
```

> [!NOTE]
> Переменные внутри условных операторов рекомендуется брать в двойные кавычки, чтобы избежать ошибок при работе с пустыми строками или строками, содержащими пробелы.

При использовании операторов `<` и `>` для строк в условных выражениях, необходимо экранировать их обратным слэшем (`\<` и `\>`) или использовать двойные квадратные скобки `[[ ]]`, чтобы избежать конфликтов с перенаправлением ввода/вывода.

Пример:

```bash
if [[ "${str1}" < "${str2}" ]]; then
    echo "${str1} лексикографически меньше ${str2}"
fi
```

__Операторы для работы с файлами:__

- `-f` : объект является обычным файлом
- `-d` : объект является директорией
- `-e` : объект существует
- `-r` : файл доступен для чтения
- `-w` : файл доступен для записи
- `-x` : файл является исполняемым
- `-s` : файл непустой

Пример:

```bash
file="script.sh"
if [ -f "${file}" ] && [ -x "${file}" ]; then
    echo "Файл существует и является исполняемым"
fi
```

__Логические операторы:__

- `&&` : логическое И (AND)
- `||` : логическое ИЛИ (OR)
- `!` : логическое НЕ (NOT)

Пример:

```bash
age=25
if [ $age -ge 18 ] && [ $age -le 65 ]; then
    echo "Возраст в рабочем диапазоне"
fi
```

#### Оператор if

Оператор ветвления `if` позволяет выполнять определенные команды в зависимости от выполнения условия. Структура оператора `if` выглядит следующим образом:

```bash
if [ condition ]; then
    commands_if_true
else
    commands_if_false
fi
```

Причем условие должно быть приводимо к логическому значению. Например, пустая строка или число 0 считаются ложью, а непустая строка или любое ненулевое число — истиной.

Альтернативное ветвление `else` является необязательным и может быть опущено, если не требуется выполнять действия при ложном условии.

Пример:

```bash
if [ -f "file.txt" ]; then
    echo "File exists"
else
    echo "File does not exist"
fi
```

Оператор `if` может быть расширен с помощью `elif` (else if) для проверки нескольких условий:

```bash
if [ condition1 ]; then
    commands_if_condition1_true
elif [ condition2 ]; then
    commands_if_condition2_true
else
    commands_if_all_conditions_false
fi
```

Инструкция `elif` может быть использована несколько раз для проверки различных условий.

Пример:

```bash
if [ $age -lt 18 ]; then
    echo "Minor"
elif [ $age -le 65 ]; then
    echo "Adult"
else
    echo "Senior"
fi
```

#### Цикл for

Цикл `for` используется для перебора элементов в списке или массиве. Синтаксис:

```bash
for item in list; do
    commands
done
```

Пример:

```bash
for fruit in apple banana cherry; do
    echo "I like ${fruit}"
done
```

Кроме того, цикл `for` может использоваться для выполнения команд с определенным числовым диапазоном с помощью конструкции `{start..end}`:

```bash
for i in {1..5}; do
    echo "Number ${i}"
done
```

Для получения элементов массива по индексам можно использовать следующий синтаксис:

```bash
array=(one two three)
for index in "${!array[@]}"; do
  echo "Element $index: ${array[$index]}"
done
```

#### Цикл while

Цикл `while` выполняет команды, пока условие истинно. Синтаксис:

```bash
while [ condition ]; do
    commands
done
```

Пример:

```bash
count=1
while [ $count -le 5 ]; do
    echo "Count: ${count}"
    ((count++))
done
```

#### Цикл until

Цикл `until` выполняет команды, пока условие ложно. Синтаксис:

```bash
until [ condition ]; do
    commands
done
```

Пример:

```bash
count=1
until [ $count -gt 5 ]; do
    echo "Count: ${count}"
    ((count++))
done
```

### Функции

Функции используются для структурирования кода, повышения его читаемости и повторного использования. Общая форма объявления функции в Bash следующая:

```bash
function_name() {
  commands
}
```

или

```bash
function function_name {
  commands
}
```

Параметры передаются функции через *позиционные параметры* `$1`, `$2` и т.д. Также внутри функции доступны специальные переменные, такие как `$#` (количество переданных аргументов) и `$@` (все аргументы).

Возврат значения функции осуществляется через вывод в стандартный поток.

Пример:

```bash
sum() {
  echo $(( $1 + $2 ))
}
value=$(sum 3 5)
echo "Sum: ${value}"  # Выведет: Sum: 8
```

Вызов функции осуществляется по её имени с передачей необходимых аргументов:

```bash
function_name arg1 arg2
```

#### Локальные переменные

По умолчанию все переменные в Bash являются глобальными, даже если они определены внутри функции. Чтобы ограничить область видимости переменной только функцией, используется ключевое слово `local`:

```bash
my_function() {
  local local_var="I am local"
  global_var="I am global"
  echo "${local_var}"
}
my_function
# echo "${local_var}"  # Ошибка: local_var не определена вне функции
echo "${global_var}"  # Выведет: I am global
```

#### Параметры Shell скрипта

Параметры, переданные скрипту при его вызове, доступны внутри скрипта через *позиционные параметры*, как и в функциях. Основные параметры:

- `$0`: имя скрипта;
- `$1`, `$2`, ...: первый, второй и т.д. аргументы;
- `$#`: количество переданных аргументов;
- `$@`: все аргументы как отдельные слова;
- `$*`: все аргументы как одна строка.

Пример:

```bash
#!/bin/bash
# Скрипт для вывода переданных аргументов
echo "Script name: $0"
echo "Total arguments: $#"
echo "All arguments: $@"

for arg in "$@"; do
  echo "Argument: ${arg}"
done

echo "Done."
```

### Обработка ошибок

Обработка ошибок осуществляется с помощью проверки кода возврата предыдущей команды (`$?`) или конструкции `set -e`, которая завершает выполнение скрипта при ошибке.

Пример:

```bash
cp file1.txt file2.txt
if [ $? -ne 0 ]; then
  echo "Ошибка копирования файла"
fi
```

или

```bash
set -e
cp file1.txt file2.txt
# Если возникнет ошибка, выполнение скрипта прекратится
```

Также можно использовать логические операторы `&&` и `||` для выполнения команд в зависимости от успеха или неудачи предыдущей команды. Общая форма:

```bash
command && command_if_success || command_if_failure
```

Пример:

```bash
mkdir new_directory && echo "Directory created" || echo "Failed to create directory"
```

### Вызов внешних команд и скриптов

Внешние команды и другие скрипты могут быть вызваны из Bash-скрипта путем указания их имени и параметров. Вызов осуществляется в отдельном процессе, а результат выполнения может быть использован в дальнейшем.

Общая форма:

```bash
command [arguments]
```

или

```bash
./a_script.sh [arguments]
```

Результат выполнения команды можно сохранить в переменную с помощью конструкции `$()`:

```bash
current_date=$(date)
echo "Current date: ${current_date}"
```

Если требуется выполнить команду в фоновом режиме, используется символ `&`:

```bash
long_running_task &
```

### Примеры простых скриптов

Ниже приведены примеры простых скриптов с пояснением результата.

#### Пример 1. Резервное копирование файла

```bash
#!/bin/bash
# first argument is source file, second is destination
if [ $# -ne 2 ]; then
  echo "Usage: $0 source_file destination_file"
  exit 1
fi

src="$1"
dest="$2"

cp "${src}" "${dest}"

if [ $? -eq 0 ]; then
  echo "Backup successful"
else
  echo "Backup failed"
fi
```

Результат: если копирование прошло успешно, будет выведено сообщение об успехе, иначе — сообщение об ошибке.

#### Пример 2. Подсчет количества строк в файле

```bash
#!/bin/bash

if [ $# -ne 1 ]; then
  echo "Usage: $0 file"
  exit 1
fi

file="$1"

if [ ! -f "${file}" ]; then
  echo "File not found!"
  exit 1
fi

lines=$(wc -l < "$file")

if [ $? -ne 0 ]; then
  echo "Error reading file"
  exit 1
fi

echo "Number of lines: $lines"
```

Результат: будет выведено количество строк в файле или сообщение об ошибке, если файл не найден или не может быть прочитан.

#### Пример 3. Подсчет количества строк в файле, функциональный стиль

```bash
#!/bin/bash

function count_lines() {
  local file="$1"
  lines=$(wc -l < "${file}")
  if [ $? -ne 0 ]; then
    echo "Error reading file"
    return 1
  fi
  echo "${lines}"
  return 0
}

if [ $# -ne 1 ]; then
  echo "Usage: $0 file"
  exit 1
fi

if [ ! -f "${1}" ]; then
  echo "File not found!"
  exit 1
fi

result=$(count_lines "${1}")
echo "Number of lines: ${result}"
```

Скрипт выполняет ту же функцию, что и предыдущий, но для логики подсчета строк определена отдельная функция `count_lines`.

#### Пример 4. Слияние нескольких текстовых файлов в один

```bash
#!/bin/bash
if [ $# -lt 2 ]; then
  echo "Usage: $0 output_file input_file1 [input_file2 ...]"
  exit 1
fi
output_file="$1"
shift
cat "$@" > "${output_file}"
if [ $? -eq 0 ]; then
  echo "Files merged into ${output_file}"
else
  echo "Error merging files"
fi
```

Результат: если слияние прошло успешно, будет выведено сообщение об успехе, иначе — сообщение об ошибке.

## Библиография

1. [Parker Steve, Shell Scripting Tutorial](https://www.shellscript.sh/)
2. [Cooper Mendel, Advanced Bash-Scripting Guide, 2014](https://tldp.org/LDP/abs/html/)
3. [Garrels Machtelt, Bash Guide for Beginners, 2008](https://tldp.org/LDP/Bash-Beginners-Guide/html/)
4. [Shotts William, The Linux Command Line](http://linuxcommand.org/tlcl.php)
5. [GNU Bash Manual](https://www.gnu.org/software/bash/manual/bash.html)
